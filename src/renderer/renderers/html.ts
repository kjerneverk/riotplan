/**
 * HTML Renderer
 *
 * Render a plan to HTML format.
 */

import type { Plan, PlanStep } from "../../types.js";

/**
 * Options for HTML rendering
 */
export interface HtmlRenderOptions {
  /** Include full HTML document (with head/body) */
  fullDocument?: boolean;

  /** Document title (defaults to plan name) */
  title?: string;

  /** Include inline CSS styles */
  includeStyles?: boolean;

  /** CSS theme: light or dark */
  theme?: "light" | "dark";

  /** Include step details */
  includeStepDetails?: boolean;

  /** Include feedback records */
  includeFeedback?: boolean;

  /** Include evidence records */
  includeEvidence?: boolean;
}

/**
 * Default options for HTML rendering
 */
const DEFAULT_OPTIONS: HtmlRenderOptions = {
    fullDocument: true,
    includeStyles: true,
    theme: "light",
    includeStepDetails: true,
    includeFeedback: false,
    includeEvidence: false,
};

/**
 * Render a plan to HTML
 */
export function renderToHtml(
    plan: Plan,
    options?: Partial<HtmlRenderOptions>,
): string {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    const title = opts.title || plan.metadata.name;

    const content = renderContent(plan, opts);

    if (!opts.fullDocument) {
        return content;
    }

    const styles = opts.includeStyles ? renderStyles(opts.theme || "light") : "";

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${escapeHtml(title)}</title>
    ${styles}
</head>
<body>
    <div class="container">
        ${content}
    </div>
</body>
</html>`;
}

/**
 * Render main content
 */
function renderContent(plan: Plan, opts: HtmlRenderOptions): string {
    const sections: string[] = [];

    // Header
    sections.push(`<header>
    <h1>${escapeHtml(plan.metadata.name)}</h1>
    ${plan.metadata.description ? `<p class="description">${escapeHtml(plan.metadata.description)}</p>` : ""}
</header>`);

    // Status overview
    sections.push(renderStatusHtml(plan));

    // Steps
    sections.push(renderStepsHtml(plan, opts));

    // Feedback
    if (opts.includeFeedback && plan.feedback?.length) {
        sections.push(renderFeedbackHtml(plan));
    }

    // Evidence
    if (opts.includeEvidence && plan.evidence?.length) {
        sections.push(renderEvidenceHtml(plan));
    }

    // Footer
    sections.push(`<footer>
    <p>Generated by RiotPlan Renderer on ${new Date().toISOString()}</p>
</footer>`);

    return sections.join("\n\n");
}

/**
 * Render status section
 */
function renderStatusHtml(plan: Plan): string {
    const state = plan.state;
    const totalSteps = plan.steps?.length ?? 0;
    const completed =
    plan.steps?.filter((s) => s.status === "completed").length ?? 0;

    return `<section class="status">
    <h2>Status Overview</h2>
    <div class="status-grid">
        <div class="status-item">
            <span class="label">Status</span>
            <span class="value status-${state.status}">${getStatusEmoji(state.status)} ${state.status}</span>
        </div>
        <div class="status-item">
            <span class="label">Progress</span>
            <div class="progress-bar">
                <div class="progress-fill" style="width: ${state.progress}%"></div>
            </div>
            <span class="value">${state.progress}%</span>
        </div>
        <div class="status-item">
            <span class="label">Steps</span>
            <span class="value">${completed} / ${totalSteps}</span>
        </div>
    </div>
</section>`;
}

/**
 * Render steps section
 */
function renderStepsHtml(plan: Plan, opts: HtmlRenderOptions): string {
    const steps = plan.steps || [];

    if (steps.length === 0) {
        return `<section class="steps">
    <h2>Steps</h2>
    <p class="empty">No steps defined.</p>
</section>`;
    }

    const stepItems = steps.map((step) => renderStepHtml(step, opts)).join("\n");

    return `<section class="steps">
    <h2>Steps</h2>
    <div class="step-list">
        ${stepItems}
    </div>
</section>`;
}

/**
 * Render individual step
 */
function renderStepHtml(step: PlanStep, opts: HtmlRenderOptions): string {
    const detailsHtml =
    opts.includeStepDetails && step.description
        ? `<p class="step-description">${escapeHtml(step.description)}</p>`
        : "";

    const dateHtml =
    step.startedAt || step.completedAt
        ? `<div class="step-dates">
            ${step.startedAt ? `<span>Started: ${formatDate(step.startedAt)}</span>` : ""}
            ${step.completedAt ? `<span>Completed: ${formatDate(step.completedAt)}</span>` : ""}
        </div>`
        : "";

    return `<div class="step step-${step.status}">
    <div class="step-header">
        <span class="step-number">${step.number}</span>
        <span class="step-title">${escapeHtml(step.title)}</span>
        <span class="step-status">${getStatusEmoji(step.status)}</span>
    </div>
    ${detailsHtml}
    ${dateHtml}
</div>`;
}

/**
 * Render feedback section
 */
function renderFeedbackHtml(plan: Plan): string {
    const feedback = plan.feedback || [];

    const items = feedback
        .map(
            (f) => `<div class="feedback-item">
        <h4>${escapeHtml(f.id)}: ${escapeHtml(f.title)}</h4>
        <div class="meta">
            <span>Platform: ${f.platform}</span>
            <span>Date: ${formatDate(f.createdAt)}</span>
        </div>
    </div>`,
        )
        .join("\n");

    return `<section class="feedback">
    <h2>Feedback</h2>
    ${items}
</section>`;
}

/**
 * Render evidence section
 */
function renderEvidenceHtml(plan: Plan): string {
    const evidence = plan.evidence || [];

    const items = evidence
        .map(
            (e) => `<div class="evidence-item">
        <h4>${escapeHtml(e.id)}: ${escapeHtml(e.title)}</h4>
        <div class="meta">
            <span>Type: ${e.type}</span>
            ${e.source ? `<span>Source: ${escapeHtml(e.source)}</span>` : ""}
        </div>
    </div>`,
        )
        .join("\n");

    return `<section class="evidence">
    <h2>Evidence</h2>
    ${items}
</section>`;
}

/**
 * Get status emoji
 */
function getStatusEmoji(status: string): string {
    const emojis: Record<string, string> = {
        not_started: "‚¨ú",
        pending: "‚¨ú",
        in_progress: "üîÑ",
        completed: "‚úÖ",
        blocked: "‚è∏Ô∏è",
        skipped: "‚è≠Ô∏è",
        cancelled: "‚ùå",
    };
    return emojis[status] || "";
}

/**
 * Format a date
 */
function formatDate(date: Date): string {
    if (typeof date === "string") {
        return date;
    }
    return date.toISOString().split("T")[0];
}

/**
 * Render CSS styles
 */
function renderStyles(theme: "light" | "dark"): string {
    const colors =
    theme === "dark"
        ? {
            bg: "#1a1a1a",
            text: "#e0e0e0",
            border: "#333",
            accent: "#4a9eff",
            success: "#4caf50",
            warning: "#ff9800",
            error: "#f44336",
        }
        : {
            bg: "#ffffff",
            text: "#333333",
            border: "#e0e0e0",
            accent: "#2196f3",
            success: "#4caf50",
            warning: "#ff9800",
            error: "#f44336",
        };

    return `<style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: ${colors.bg};
        color: ${colors.text};
        line-height: 1.6;
    }
    .container { max-width: 900px; margin: 0 auto; padding: 2rem; }
    header { margin-bottom: 2rem; }
    h1 { font-size: 2rem; margin-bottom: 0.5rem; }
    h2 { font-size: 1.5rem; margin-bottom: 1rem; border-bottom: 2px solid ${colors.accent}; padding-bottom: 0.5rem; }
    .description { color: ${colors.text}; opacity: 0.8; }
    
    section { margin-bottom: 2rem; }
    
    .status-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }
    .status-item { padding: 1rem; border: 1px solid ${colors.border}; border-radius: 8px; }
    .status-item .label { display: block; font-size: 0.875rem; opacity: 0.7; margin-bottom: 0.25rem; }
    .status-item .value { font-weight: bold; }
    
    .progress-bar { height: 8px; background: ${colors.border}; border-radius: 4px; overflow: hidden; margin: 0.5rem 0; }
    .progress-fill { height: 100%; background: ${colors.accent}; transition: width 0.3s; }
    
    .step-list { display: flex; flex-direction: column; gap: 0.75rem; }
    .step { padding: 1rem; border: 1px solid ${colors.border}; border-radius: 8px; }
    .step-header { display: flex; align-items: center; gap: 0.75rem; }
    .step-number { font-weight: bold; color: ${colors.accent}; min-width: 2rem; }
    .step-title { flex: 1; }
    .step-description { margin-top: 0.5rem; opacity: 0.8; font-size: 0.9rem; }
    .step-dates { margin-top: 0.5rem; font-size: 0.8rem; opacity: 0.6; }
    
    .step-completed { border-left: 4px solid ${colors.success}; }
    .step-in_progress { border-left: 4px solid ${colors.accent}; }
    .step-blocked { border-left: 4px solid ${colors.warning}; }
    
    .feedback-item, .evidence-item { padding: 1rem; border: 1px solid ${colors.border}; border-radius: 8px; margin-bottom: 0.75rem; }
    .meta { font-size: 0.8rem; opacity: 0.7; margin: 0.5rem 0; }
    .meta span { margin-right: 1rem; }
    
    footer { margin-top: 3rem; padding-top: 1rem; border-top: 1px solid ${colors.border}; font-size: 0.8rem; opacity: 0.6; }
    
    .empty { opacity: 0.6; font-style: italic; }
</style>`;
}

/**
 * Escape HTML entities
 */
function escapeHtml(text: string): string {
    return text
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}
